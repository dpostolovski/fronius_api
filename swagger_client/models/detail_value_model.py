# coding: utf-8

"""
    ThirdPartyApi

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: v1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.models.value_unit import ValueUnit  # noqa: F401,E501


class DetailValueModel(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'channel_type': 'str',
        'dalo_id': 'str',
        'device_id': 'str',
        'node_type': 'int',
        'device_type': 'int',
        'log_date_time': 'datetime',
        'value': 'ValueUnit'
    }

    attribute_map = {
        'channel_type': 'ChannelType',
        'dalo_id': 'DaloId',
        'device_id': 'DeviceId',
        'node_type': 'NodeType',
        'device_type': 'DeviceType',
        'log_date_time': 'LogDateTime',
        'value': 'Value'
    }

    def __init__(self, channel_type=None, dalo_id=None, device_id=None, node_type=None, device_type=None, log_date_time=None, value=None):  # noqa: E501
        """DetailValueModel - a model defined in Swagger"""  # noqa: E501

        self._channel_type = None
        self._dalo_id = None
        self._device_id = None
        self._node_type = None
        self._device_type = None
        self._log_date_time = None
        self._value = None
        self.discriminator = None

        if channel_type is not None:
            self.channel_type = channel_type
        if dalo_id is not None:
            self.dalo_id = dalo_id
        if device_id is not None:
            self.device_id = device_id
        if node_type is not None:
            self.node_type = node_type
        if device_type is not None:
            self.device_type = device_type
        if log_date_time is not None:
            self.log_date_time = log_date_time
        if value is not None:
            self.value = value

    @property
    def channel_type(self):
        """Gets the channel_type of this DetailValueModel.  # noqa: E501

        Channel type of value.  # noqa: E501

        :return: The channel_type of this DetailValueModel.  # noqa: E501
        :rtype: str
        """
        return self._channel_type

    @channel_type.setter
    def channel_type(self, channel_type):
        """Sets the channel_type of this DetailValueModel.

        Channel type of value.  # noqa: E501

        :param channel_type: The channel_type of this DetailValueModel.  # noqa: E501
        :type: str
        """
        allowed_values = ["Unknown", "Temperature1", "Temperature2", "Insolation", "Digital1", "Digital2", "Digital3", "Digital1Energy", "Digital2Energy", "Digital3Energy", "UACMeanLine1", "UACMeanLine2", "UACMeanLine3", "LogPeriode", "DevWork", "DevWorkPerKwp", "UACMeanL1", "UACMeanL2", "UACMeanL3", "IACMeanL1", "IACMeanL2", "IACMeanL3", "UDCMean", "IDCMean", "InverterTempMean", "AmbientTempMean", "RoomTempMean", "PModuleTempMean", "PCBTempMean", "RelHumidityMean", "SACMean", "Power", "Income", "InsolationEnergy", "DevWorkReactiveInductive", "DevWorkReactiveCapacitive", "AcModuleTempMean", "DcModuleTempMean", "DcModuleTempMean1", "DcModuleTempMean2", "UDCMean2", "IDCMean2", "PContentDc2", "CO2", "PowerPct", "SensorWindSpeed", "SensorTemperature", "SensorVelocity", "SensorEnergy", "SensorPower", "PowerReactiveInductive", "PowerReactiveCapacitive", "PowerReactive", "PowerApparent", "CosPhi", "MPPEnergy1", "MPPEnergy2", "MPPEnergy1Abs", "MPPEnergy2Abs", "MPPPower1", "MPPPower2", "EnergyGridPlusAbs", "EnergyGridMinusAbs", "EnergyGridMinus", "EnergyGridPlus", "DevWorkExAbs", "EnergyLoadAbs", "DevWorkEx", "EnergyLoad", "EnergyBattPlus", "EnergyBattMinus", "EnergyBattPlusAbs", "EnergyBattMinusAbs", "GPIOState", "EnergyOwnConsumption", "EnergyGeneratorsPlus", "EnergyGeneratorsPlusAbs", "EnergyGeneratorsMinus", "EnergyGeneratorsMinusAbs", "StateOfCharge", "BattTempAvg", "BattTempMin", "BattTempMax", "BattVoltageDC", "DevWorkNeg", "DevWorkDC1", "DevWorkDC1Neg", "BattOperatingState", "BattCellStatus", "BattWarningCode", "BattCycleCount", "BattManSysStatus", "BattPowerstageStatus", "BattStatus", "FromInverter", "BatteryExpense", "BatteryIncome", "Expense", "ExpenseNoPv", "ToConsumer", "FromGenToConsumer", "FromGenToGrid", "FromGenToBatt", "FromBattToGrid", "FromBattToConsumer", "FromGridToConsumer", "FromGridToBatt", "FromGen", "FromGenToSomewhere", "Saving", "OhmPilotTemp", "OhmPilotEnergyAbs", "OhmPilotEnergy", "OhmPilotErrorCode", "GridPowerAcPhase1", "GridPowerAcPhase2", "GridPowerAcPhase3", "GridApparentPowerPhase1", "GridApparentPowerPhase2", "GridApparentPowerPhase3", "GridVoltageAcPhase1", "GridVoltageAcPhase2", "GridVoltageAcPhase3", "LoadPowerAcPhase1", "LoadPowerAcPhase2", "LoadPowerAcPhase3", "LoadApparentPowerPhase1", "LoadApparentPowerPhase2", "LoadApparentPowerPhase3", "LoadVoltageAcPhase1", "LoadVoltageAcPhase2", "LoadVoltageAcPhase3", "OhmPilotCodeOfState", "BattCellVoltageMin", "BattCellVoltageMax", "ToGrid", "FromGrid", "InverterOperatingTimeTotal", "InverterOperatingTimeBackup", "FromGenToOhmPilot", "FromBattToOhmPilot", "FromGridToOhmPilot", "BattCurrentDC", "BattPowerLimitDischarge", "BattPowerLimitCharge", "BattTargetPower", "BattFullEnergyAvailable", "BattEnergyRemaining", "BattLifetimeEnergyCharged", "BattLifetimeEnergyDischarged", "BattVoltage", "BattCurrent", "BattWakeEnableStatus", "BattStateOfHealth", "BattTempAmbient", "EnergyPvGenerator", "MPPEnergy1PerKwp", "MPPEnergy2PerKwp", "SubDevWorkExAbs", "SubDevWorkEx", "SubEnergyLoadAbs", "SubEnergyLoad", "SubPowerAcPhase1", "SubPowerAcPhase2", "SubPowerAcPhase3", "SubApparentPowerPhase1", "SubApparentPowerPhase2", "SubApparentPowerPhase3", "SubVoltageAcPhase1", "SubVoltageAcPhase2", "SubVoltageAcPhase3", "GeneratorIsolation", "ExternalPowerAcPhase1", "ExternalPowerAcPhase2", "ExternalPowerAcPhase3", "ExternalApparentPowerPhase1", "ExternalApparentPowerPhase2", "ExternalApparentPowerPhase3", "ExternalVoltageAcPhase1", "ExternalVoltageAcPhase2", "ExternalVoltageAcPhase3", "DevWorkAllPlus", "DevWorkAllPlusAbs", "DevWorkAllMinus", "DevWorkAllMinusAbs", "LastFaultParams", "DrooplawDeadbandLowerLimit", "DrooplawDeadbandUpperLimit", "DrooplawChargeSlope", "DrooplawDischargeSlope", "DrooplawChargePowerLimit", "DrooplawDischargePowerLimit", "DrooplawChargeVoltageLimit", "DrooplawDischargeVoltageLimit", "CbStatus", "MeterLocationCurrent", "PvForecast", "TemperatureMinForecast", "TemperatureMaxForecast", "TemperatureForecast", "InclinedGlobalRadiation", "InclinedGlobalRadiationClearSky", "HorizontalGlobalRadiation", "PrecipitationForecast", "WindSpeedForecast", "CloudCoverForecast", "WeatherSymbols", "WeatherDaySymbols", "SunriseTimes", "SunsetTimes", "DevWorkAbs", "DevWorkNegAbs", "DevWorkReactiveCapacitiveAbs", "DevWorkReactiveInductiveAbs", "DevWorkDC1Abs", "DevWorkDC2Abs", "DevWorkDC2", "TemperatureDCModule01", "TemperatureDCModule02", "TemperatureDCModule03", "TemperatureDCModule04", "TemperatureACModule01", "TemperatureACModule02", "TemperatureACModule03", "TemperatureACModule04", "TemperatureACModule05", "TemperatureACModule06"]  # noqa: E501
        if channel_type not in allowed_values:
            raise ValueError(
                "Invalid value for `channel_type` ({0}), must be one of {1}"  # noqa: E501
                .format(channel_type, allowed_values)
            )

        self._channel_type = channel_type

    @property
    def dalo_id(self):
        """Gets the dalo_id of this DetailValueModel.  # noqa: E501

        Dalo for value.  # noqa: E501

        :return: The dalo_id of this DetailValueModel.  # noqa: E501
        :rtype: str
        """
        return self._dalo_id

    @dalo_id.setter
    def dalo_id(self, dalo_id):
        """Sets the dalo_id of this DetailValueModel.

        Dalo for value.  # noqa: E501

        :param dalo_id: The dalo_id of this DetailValueModel.  # noqa: E501
        :type: str
        """

        self._dalo_id = dalo_id

    @property
    def device_id(self):
        """Gets the device_id of this DetailValueModel.  # noqa: E501

        Device id for value.  # noqa: E501

        :return: The device_id of this DetailValueModel.  # noqa: E501
        :rtype: str
        """
        return self._device_id

    @device_id.setter
    def device_id(self, device_id):
        """Sets the device_id of this DetailValueModel.

        Device id for value.  # noqa: E501

        :param device_id: The device_id of this DetailValueModel.  # noqa: E501
        :type: str
        """

        self._device_id = device_id

    @property
    def node_type(self):
        """Gets the node_type of this DetailValueModel.  # noqa: E501

        Node type of device.  # noqa: E501

        :return: The node_type of this DetailValueModel.  # noqa: E501
        :rtype: int
        """
        return self._node_type

    @node_type.setter
    def node_type(self, node_type):
        """Sets the node_type of this DetailValueModel.

        Node type of device.  # noqa: E501

        :param node_type: The node_type of this DetailValueModel.  # noqa: E501
        :type: int
        """

        self._node_type = node_type

    @property
    def device_type(self):
        """Gets the device_type of this DetailValueModel.  # noqa: E501

        Device type of device.  # noqa: E501

        :return: The device_type of this DetailValueModel.  # noqa: E501
        :rtype: int
        """
        return self._device_type

    @device_type.setter
    def device_type(self, device_type):
        """Sets the device_type of this DetailValueModel.

        Device type of device.  # noqa: E501

        :param device_type: The device_type of this DetailValueModel.  # noqa: E501
        :type: int
        """

        self._device_type = device_type

    @property
    def log_date_time(self):
        """Gets the log_date_time of this DetailValueModel.  # noqa: E501

        Log time of value.  # noqa: E501

        :return: The log_date_time of this DetailValueModel.  # noqa: E501
        :rtype: datetime
        """
        return self._log_date_time

    @log_date_time.setter
    def log_date_time(self, log_date_time):
        """Sets the log_date_time of this DetailValueModel.

        Log time of value.  # noqa: E501

        :param log_date_time: The log_date_time of this DetailValueModel.  # noqa: E501
        :type: datetime
        """

        self._log_date_time = log_date_time

    @property
    def value(self):
        """Gets the value of this DetailValueModel.  # noqa: E501

        Value with unit.  # noqa: E501

        :return: The value of this DetailValueModel.  # noqa: E501
        :rtype: ValueUnit
        """
        return self._value

    @value.setter
    def value(self, value):
        """Sets the value of this DetailValueModel.

        Value with unit.  # noqa: E501

        :param value: The value of this DetailValueModel.  # noqa: E501
        :type: ValueUnit
        """

        self._value = value

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(DetailValueModel, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DetailValueModel):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
